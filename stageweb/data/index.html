<!DOCTYPE html>
<html>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/palette.js@master/palette.js"></script>
<body>

<div style="display: flex; align-items: center;">
  <label for="courseSelect">Select course:</label>
  <select id="courseSelect"></select>
  <label for="filterSelect" style="margin-left: 20px;">Filter:</label>
  <select id="filterSelect">
    <option value="all:all">All</option>
    <option value="gender:M">Male</option>
    <option value="gender:W">Female</option>
  </select>
  <div id="timerBox" style="margin-left: 20px;"></div>
  <div id="refreshMessage" style="margin-left: 20px;"></div>
</div>

<canvas id="myChart" style="width:50%"></canvas>

<script>

let courseNo = '999';
let filter = 'all';
let apiUrl = 'https://stageweb.fly.dev'
let dataUrl = `${apiUrl}/chart?course=${courseNo}&filter=${filter}`;
let chart;

async function getData(dataUrl) {
  const data = fetch(dataUrl)
    .then(res => res.json())
    .catch(error => {
        console.error('Error fetching data:', error);
        document.getElementById('refreshMessage').textContent = `Error: ${error.message}`;
        document.getElementById('refreshMessage').style.color = 'red';
    });
  return data;
}

function makeChart(data) {
  chart = new Chart("myChart", {
    type: "bar",
    data: {
      datasets: [{
        label: "splits",
        // see https://github.com/google/palette.js
        backgroundColor: palette('tol', data.length).map(function(hex) {
          return '#' + hex;
        }),
        // https://www.chartjs.org/docs/latest/general/data-structures.html
        data: data
      }]
    },
    options: {
      parsing: {
        xAxisKey: 'stageName',
        yAxisKey: 'numRunners'
      },
      title: {
        display: true,
        text: "Stuff of legends"
      },
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          enabled: false
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          // max: data.length,
          // to prevent fractionals
          suggestedMax: 10,
          title: {
            display: true,
            text: 'Num of them'
          }
        },
        x: {
          title: {
            display: false,
            text: 'Splits'
          }
        }
      }
    }
  });
  return chart;
}

const timerBox = document.getElementById('timerBox');
const courseSelect = document.getElementById('courseSelect');
const filterSelect = document.getElementById('filterSelect');
const refreshMessage = document.getElementById('refreshMessage');
refreshInterval = 10000;
timerBox.textContent = `Refresh every ${refreshInterval / 1000}s`;
let lastRefreshTime = Date.now();

async function updateChart() {
  courseNo = courseSelect.value;
  filter = filterSelect.value;
  dataUrl = `${apiUrl}/chart?course=${courseNo}&filter=${filter}`;
  data = await getData(dataUrl);
  if (data) {
    console.log("got data:", data);
    if (chart) {
      chart.data.datasets[0].data = Object.values(data.stages);
      chart.data.datasets[0].backgroundColor = palette('tol', data.stages.length).map(function(hex) {
        return '#' + hex;
      });
      chart.update();
    } else {
      chart = makeChart(data.stages);
    }
    lastRefreshTime = Date.now();
    const date = new Date(lastRefreshTime);
    const time = date.toLocaleTimeString();
    refreshMessage.textContent = `Refreshed at ${time}`;
    refreshMessage.style.color = 'black';
  }
}

async function populateCourseSelect() {
  const courses = await getData(`${apiUrl}/courses`);
  courses.forEach(course => {
    const option = document.createElement('option');
    option.value = course.courseID;
    option.textContent = course.courseName;
    courseSelect.appendChild(option);
  });
  courseSelect.addEventListener('change', updateChart);
  filterSelect.addEventListener('change', updateChart);
  updateChart();
}

populateCourseSelect();

let refreshTimer = setInterval(updateChart, refreshInterval);

setInterval(() => {
  const timeLeft = refreshInterval - (Date.now() - lastRefreshTime);
  if (timeLeft < 1000) {
    timerBox.textContent = `Refreshing`;
  } else {
    timerBox.textContent = `Refresh in ${Math.round(timeLeft / 1000)}s`;
  }
}, 1000)

filterSelect.addEventListener('change', () => {
  clearInterval(refreshTimer);
  lastRefreshTime = Date.now();
  updateChart();
  refreshTimer = setInterval(updateChart, refreshInterval);
});

</script>

</body>
</html>
